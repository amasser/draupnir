#!/usr/bin/env bash

set -e
set -u
set -o pipefail

if ! [[ "$#" -eq 4 ]]; then
  echo """
  Desc:  Prepares an image for launching instances
  Usage: $(basename "$0") ROOT INSTANCE_ID PORT ANON_FILE
  Example:

      $(basename "$0") /draupnir 999 6543 anon.sql

  The steps taken are:

  1. Extract and remove any tar files in the directory
  2. Remove pid files, if present
  3. Set the correct permissions to boot postgres
  4. Install our own postgresql.conf and pg_hba.conf
  5. Boot postgres
  6. Run the anonymisation script
  7. Stop postgres
  8. Take a BTRFS snapshot of the directory
  """
  exit 1
fi

PG_CTL=/usr/lib/postgresql/9.4/bin/pg_ctl
VACUUMDB=/usr/lib/postgresql/9.4/bin/vacuumdb
PSQL=/usr/bin/psql

ROOT=$1
ID=$2
PORT=$3
ANON_FILE=$4

# TODO: validate input

UPLOAD_PATH="${ROOT}/image_uploads/${ID}"
SNAPSHOT_PATH="${ROOT}/image_snapshots/${ID}"

set -x

sudo mkdir -p "${UPLOAD_PATH}/tmp"

if sudo sh -c "ls ${UPLOAD_PATH}/*.tar*"; then
	sudo sh -c "tar xf ${UPLOAD_PATH}/*.tar* -C ${UPLOAD_PATH}/tmp"
	sudo sh -c "mv ${UPLOAD_PATH}/tmp/* ${UPLOAD_PATH}/"
	sudo rmdir "${UPLOAD_PATH}/tmp"
	sudo sh -c "rm -f ${UPLOAD_PATH}/*.tar*" # remove the compressed backup file(s)
fi

if ! sudo -u postgres /usr/lib/postgresql/9.4/bin/pg_controldata "${UPLOAD_PATH}"; then
	echo "image upload is not valid postgresql data directory"
	exit 255
fi

sudo rm -f "${UPLOAD_PATH}/postmaster.pid"
sudo rm -f "${UPLOAD_PATH}/postmaster.opts"
sudo chown -R postgres "$UPLOAD_PATH"
sudo chmod 700 "$UPLOAD_PATH"

# Install our own postgresql.conf
cat > "${UPLOAD_PATH}/postgresql.conf" <<- EOF
datestyle = 'iso, mdy'
default_text_search_config = 'pg_catalog.english'
lc_messages = 'C'
listen_addresses = '*'
log_autovacuum_min_duration = 0
log_checkpoints = 'on'
log_connections = 'on'
log_disconnections = 'on'
log_line_prefix = '%t [%p]: [%l-1] user=%u,db=%d,app=%a '
log_lock_waits = 'on'
log_min_duration_statement = 500
log_temp_files = 0
maintenance_work_mem = '256MB'
max_connections = 150
shared_preload_libraries = 'pg_stat_statements'
ssl = on
ssl_cert_file = '/etc/ssl/certs/ssl-cert-snakeoil.pem'
ssl_key_file = '/etc/ssl/private/ssl-cert-snakeoil.key'
temp_file_limit = 5242880 # 5GiB
work_mem = '128MB'

# Turn off hot standby as we won't ever need to run queries against this
# database while it's in recovery. We also want to reduce- as much as is
# possible- the amount of WAL we write during finalisation, as this step usually
# requires a significant amount of IO. Similarly, fsync should be turned off
# during finalisation.
hot_standby = 'off'
wal_level = 'minimal'
fsync = 'off'
EOF

LOG_FILE="/var/log/postgresql/image_${ID}"

# Start postgres
sudo -u postgres $PG_CTL -w -D "$UPLOAD_PATH" -o "-p $PORT" -l "${LOG_FILE}" start

# We need to wait for postgres to boot and announce that the recovery has
# completed. Ideally WAL recovery shouldn't take long, but for high volume
# databases Postgres needs a window to catch-up from the last checkpoint.
TIMEOUT=600 # 10m
sudo -u postgres touch "${LOG_FILE}" # otherwise we'll fail grep'ing the file
until grep "database system is ready to accept connections" "${LOG_FILE}"
do
  if [ $(( TIMEOUT-- )) -eq 0 ];
  then
    cat "${LOG_FILE}" >&2
    echo "Postgres recovery failed, timed out waiting for recovery" >&2
    exit 255
  fi
  sleep 1
done

# Create a user
sudo -u postgres createuser --port="$PORT" -d -r -s draupnir

# Anonymise
echo "Executing anonymisation script $ANON_FILE"
sudo cat "$ANON_FILE" | sudo -u draupnir "$PSQL" -p "$PORT" --username=draupnir postgres

echo "Vacuum all the databases in the cluster"
sudo -u postgres bash <<BASH
export PGPORT="$PORT"
for database in \$(psql -t -c "select datname from pg_database where not datname like 'template%';");
do
  echo ">> vacuuming \$database"
  psql --dbname "\$database" -t -c "select table_name from information_schema.tables where table_schema='public';" \
    | xargs -P5 -n1 "$VACUUMDB" --dbname "\$database" --table
done
BASH

echo "Turning back on fsync and hot_standby wal level"
sed -i \
  "s/wal_level = 'off'/wal_level = 'hot_standby'/; s/fsync = 'off'/fsync = 'on'/" \
  "${UPLOAD_PATH}/postgresql.conf"

sudo -u postgres $PG_CTL -D "$UPLOAD_PATH" -w stop
sudo rm -f "${UPLOAD_PATH}/postmaster.pid"
sudo rm -f "${UPLOAD_PATH}/postmaster.opts"

# Install our own pg_hba.conf
printf "local\tall\tall\t\ttrust\nhost\tall\tall\t0.0.0.0/0\ttrust\n" | sudo tee "${UPLOAD_PATH}/pg_hba.conf"

btrfs subvolume snapshot "$UPLOAD_PATH" "$SNAPSHOT_PATH"

set +x
